
// initialise the intermediate hash values (IHVs)
inline fn __init_ihv() -> stack u32[8] {
  // initial values of the IHVs according to the Secure Hash Standard (SHS)
  stack u32[8] ihv;
  ihv[0] = 0x6a09e667;
  ihv[1] = 0xbb67ae85;
  ihv[2] = 0x3c6ef372;
  ihv[3] = 0xa54ff53a;
  ihv[4] = 0x510e527f;
  ihv[5] = 0x9b05688c;
  ihv[6] = 0x1f83d9ab;
  ihv[7] = 0x5be0cd19;
  
  return ihv;
}

// compute how many blocks are filled fully with message bytes,
// compute whether or or two blocks containing padding are at the end, and
// compute the last block(s) with padding
inline fn __f_pad(reg u64 mess bytes) -> stack u64, stack u32[32], stack u8{
  stack u32[32] last_blocks; // will hold the actual last block(s) with padding
  stack u8 num_last_blocks;  // number indicating whether one or two blocks are at the end
  num_last_blocks = 1;

  // compute the quotient and remainder of bytes / block size, where block size = 64 bytes
  reg u64 quot rest;
  quot   = bytes;
  quot >>= 6;     // rightshift 6 = quotient of divide by 2^6=64
  rest   = bytes;
  rest  &= 0x7F;  // AND with bitmask 0x7F=0b111111 = remainder of divide by 2^6=64

  // need 8 bytes to encode the length and 1 byte to encode the separator bit
  // if the remainder of the message exceeds 64 - 8 - 1 = 55 bytes, need an extra block for padding
  if rest > 55 {
    num_last_blocks = 2; // need an extra block
  }

  // copy the bytes of the last block of the message
  reg u64 mess_i; // byte index of the last block of the message
  mess_i  = quot; // set to the number of blocks
  mess_i *= 64;   // multiply by bytes per block
  inline u64 i;
  i = 0;
  while (i<rest) {
    last_blocks[u8 (int) i] = (u8)[mess + mess_i + i];
    i += 1;
  }

  // add the single padding bit
  last_blocks[u8 (int) i] = 0x80; // 0x80 = 0b10000000
  i += 1;

  // fill with zero-padding
  reg u64 target;
  if (num_last_blocks == 1) {
    target = 56;
  } else { // two blocks are needed
    target = 120;
  }

  while (i<target) {
    last_blocks[u8 (int) i] = 0x0;
    i += 1;
  }

  // append the message length
  last_blocks[i] = bytes;

  stack u64 stack_quot;
  stack_quot = quot;
  return stack_quot, last_blocks, num_last_blocks;
}

// sigma_0 fuction for confuscating words for the message schedule
inline fn __sigma_0(reg u32 w) -> reg u32 {
  // compute the two right rotations and the right shift
  reg u32 w1 w2 w3;
  w3 = w;
  _, _, w1 = #ROR_32(w, 7);  // w rot 7
  _, _, w2 = #ROR_32(w, 18); // w rot 18
  w3 >>= 3;                  // w >>  3
  
  w1 ^= w2;                  // (w rot 7) ^ (w rot 18)
  w1 ^= w3;                  // (w rot 7) ^ (w rot 18) ^ (w >> 3)

  return w1;                 // (w rot 7) ^ (w rot 18) ^ (w >> 3)
}

// sigma_1 fuction for confuscating words for the message schedule
inline fn __sigma_1(reg u32 w) -> reg u32 {
  // compute the two right rotations and the right shift
  reg u32 w1 w2 w3;
  w3 = w;
  _, _, w1 = #ROR_32(w, 17); // w rot 17
  _, _, w2 = #ROR_32(w, 19); // w rot 19
  w3 >>= 10;                 // w >>  10
  
  w1 ^= w2;                  // (w rot 17) ^ (w rot 19)
  w1 ^= w3;                  // (w rot 17) ^ (w rot 19) ^ (w >> 10)

  return w1;                 // (w rot 17) ^ (w rot 19) ^ (w >> 10)
}

// compute the next word for the message schedule
inline fn __f_word(reg u32 w_i2 w_i7 w_i15 w_i16) -> reg u32 {
  reg u32 w_i temp;
  temp = __sigma_0(w_i15);

  w_i  = __sigma_1(w_i2);  // sigma_1(w_{i-2})
  w_i += w_i7;             // sigma_1(w_{i-2}) + w_{i-7}
  w_i += temp;             // sigma_1(w_{i-2}) + w_{i-7} + sigma_0(w_{i-15})
  w_i += w_i16;            // sigma_1(w_{i-2}) + w_{i-7} + sigma_0(w_{i-15}) + w_{i-16}

  return w_i;              // sigma_1(w_{i-2}) + w_{i-7} + sigma_0(w_{i-15}) + w_{i-16}
}

// take a message block and produce a message schedule from it
inline fn __f_sch(stack u32[16] block) -> reg u32[64] {
  reg u32[64] sch; // message schedule

  // copy the message block into the first 16 words
  inline int i;
  for i=0 to 16 {
    sch[i] = block[i];
  }

  // compute the rest of the words in the message schedule
  for i=16 to 64 {
    sch[i] = __f_word(sch[i-2], sch[i-7], sch[i-15], sch[i-16]);
  }

  return sch; // return the entire message schedule
}

// Sigma_0 fuction for confuscating words in the main loop
inline fn __Sigma_0(reg u32 w) -> reg u32 {
  // compute the three right rotations
  reg u32 w1 w2 w3;
  _, _, w1 = #ROR_32(w, 2);  // w rot 2
  _, _, w2 = #ROR_32(w, 13); // w rot 13
  _, _, w3 = #ROR_32(w, 22); // w rot 22
  
  w1 ^= w2;                  // (w rot 2) ^ (w rot 13)
  w1 ^= w3;                  // (w rot 2) ^ (w rot 13) ^ (w rot 22)

  return w1;                 // (w rot 2) ^ (w rot 13) ^ (w rot 22)
}

// Sigma_1 fuction for confuscating words in the main loop
inline fn __Sigma_1(reg u32 w) -> reg u32 {
  // compute the three right rotations
  reg u32 w1 w2 w3;
  _, _, w1 = #ROR_32(w, 6);  // w rot 6
  _, _, w2 = #ROR_32(w, 11); // w rot 11
  _, _, w3 = #ROR_32(w, 25); // w rot 25
  
  w1 ^= w2;                  // (w rot 6) ^ (w rot 11)
  w1 ^= w3;                  // (w rot 6) ^ (w rot 11) ^ (w rot 25)

  return w1;                 // (w rot 6) ^ (w rot 11) ^ (w rot 25)
}

// majority function that computes the bitwise majority of three words
inline fn __f_maj(reg u32 x y z) -> reg u32 {
  reg u32 maj temp;

  maj   = x;    // x
  maj  &= y;    // x & y
  temp  = x;    // x
  temp &= z;    // x & z
  maj  ^= temp; // (x & y) ^ (x & z)
  temp  = y;    // y
  temp &= z;    // y & z
  maj  ^= temp; // (x & y) ^ (x & z) ^ (y & z)

  return maj;
}

// choice function that selects the bits from y and z based on the bits in x
inline fn __f_cho(reg u32 x y z) -> reg u32 {
  reg u32 cho temp;

  cho   = x;     // x
  cho  &= y;     // x & y
  temp  = x;     // x
  temp  = !temp; // !x
  temp &= z;     // !x & z
  cho  ^= temp;  // (x & y) ^ (!x & z)

  return cho;
}

// round function that takes the working variables and updates them
inline fn f_rou(reg u32 t_a t_b t_c t_d t_e t_f t_g t_h w_i k_i)
-> reg u32, reg u32, reg u32, reg u32, reg u32, reg u32, reg u32, reg u32 {
  reg u32 t_1 t_2 fun;

  // compute t_1
  t_1  = t_h;                   // t_1 = t_h
  t_1 += w_i;                   // t_1 = t_h + w_i
  t_1 += k_i;                   // t_1 = t_h + w_i + k_i
  fun = __f_cho(t_e, t_f, t_g); // fun = f_cho(t_e, t_f, t_g)
  t_1 += fun;                   // t_1 = t_h + w_i + k_i + f_cho(t_e, t_f, t_g)
  fun = __Sigma_1(t_e);         // fun = Sigma_1(t_e)
  t_1 += fun;                   // t_1 = t_h + w_i + k_i + f_cho(t_e, t_f, t_g) + Sigma_1(t_e)

  // compute t_2
  t_2  = t_1;                   // t_2 = t_1
  fun = __f_maj(t_a, t_b, t_c); // fun = f_maj(t_a, t_b, t_c)
  t_2 += fun;                   // t_2 = t_1 + f_maj(t_a, t_b, t_c)
  fun = __Sigma_0(t_a);         // fun = Sigma_0(t_a)
  t_2 += fun;                   // t_2 = t_1 + f_maj(t_a, t_b, t_c) + Sigma_0(t_a)

  // update the working variables
  t_h  = t_g;
  t_g  = t_f;
  t_f  = t_e;
  t_e  = t_d; t_e += t_1;
  t_d  = t_c;
  t_c  = t_b;
  t_b  = t_a;
  t_a  = t_1; t_a += t_2;

  return t_a, t_b, t_c, t_d, t_e, t_f, t_g, t_h;
}

// take the IHVs from the stack, swap their byte order, and overwrite the hash value
inline fn __set_hash(stack u32[8] ihv, reg u64 hash) {
  reg u32 swap;

  inline int i;
  for i=0 to 8 {
    swap = ihv[i];            // copy one 32-bit word of the IHVs from the stack into a reg
    swap = #BSWAP_32(swap);   // swap the byte order (#BSWAP_32 requires a reg argument)
    (u32)[hash + i*4] = swap; // write the swapped word to the hash value
  }
}

// take a byte sequence mess_in with length bytes_in, and compute and store its hash value at hash_in
inline fn __sha256_ref_alt(reg u64 hash_in mess_in bytes_in) {
  // store the parameter addresses on the stack
  stack u64 hash;
  hash = hash_in;

  // compute the message padding
  stack u64 num_first_blocks; // number indicating the number of blocks fully filled with message bytes
  stack u8 num_last_blocks;   // number indicating the number of blocks containing padding
  stack u32[32] last_blocks;  // space for two blocks of 512 bits, split in 32-bit words
  num_first_blocks, last_blocks, num_last_blocks = __f_pad(mess_in, bytes_in);

  // initialise the IHVs on the stack
  stack u32[8] ihv;
  ihv = __init_ihv();

  // run the compression function iteratively on message blocks consisting fully of message bytes
  // __f_comp_first(ihv, mess_in, num_first_blocks)

  // run the compression function on the last (two) message block(s) containing padding
  // __f_comp_last(ihv, last_blocks, num_last_blocks)

  // set the hash value to the IHVs
  __set_hash(ihv, hash);
}



























