
require "sha256_constants.jinc"

// initialise the intermediate hash values (IHVs)
inline fn __init_ihv() -> stack u32[8] {
  stack u32[8] ihv;
  reg u32 swap;
  
  // copy the values from the sha256_constants file
  inline int i;
  for i=0 to 8 {
    swap = SHA256_ihv[i];
    swap = #BSWAP_32(swap);
    ihv[i] = swap;
  }
  
  return ihv;
}

// compute how many blocks are filled fully with message bytes,
// compute whether or or two blocks containing padding are at the end, and
// compute the last block(s) with padding
inline fn __f_pad(reg u64 mess bytes) -> stack u64, stack u32[32], reg u64 {
  stack u32[32] last_blocks; // will hold the actual last block(s) with padding
  reg u64 num_last_blocks;    // number indicating whether one or two blocks are at the end
  num_last_blocks = 1;

  // compute the quotient and remainder of bytes / block size, where block size = 64 bytes
  reg u64 quot rest;
  quot   = bytes;
  quot >>= 6;     // rightshift 6 = quotient of divide by 2^6=64
  rest   = bytes;
  rest  &= 0x3F;  // AND with bitmask 0x3F=0b00111111 = remainder of divide by 2^6=64

  // need 8 bytes to encode the length and 1 byte to encode the separator bit
  // if the remainder of the message exceeds 64 - 8 - 1 = 55 bytes, need an extra block for padding
  if rest > 55 {
    num_last_blocks = 2; // need an extra block
  }

  // copy the bytes of the last block of the message
  reg u64 mess_i; // byte index of the last block of the message
  mess_i   = quot; // set to the number of blocks
  mess_i <<= 6;    // multiply by 64 bytes per block
  reg u64 i;
  i = 0;
  while (i<rest) {
    last_blocks[u8 (int) i] = (u8)[mess + mess_i];
    i += 1;
    mess_i += 1;
  }

  // add the single padding bit
  last_blocks[u8 (int) i] = 0x80; // 0x80 = 0b10000000
  i += 1;

  // fill with zero-padding: find target index to fill to
  reg u64 target;
  if (num_last_blocks == 1) {
    target = 56;  // 64 - 8 bytes for the length encoding
  } else {        // two blocks are needed
    target = 120; // 128 - 8 bytes for the length encoding
  }

  // fill with zero-padding: actually write zeroes
  while (i<target) {
    last_blocks[u8 (int) i] = 0x0;
    i += 1;
  }

  // append the message length
  target >>= 3; // convert to index of 64-bit word
  bytes <<= 3;  // convert to number of bits
  bytes = #BSWAP_64(bytes);
  last_blocks[u64 (int) target] = bytes;

  stack u64 stack_quot;
  stack_quot = quot;
  stack u64 stack_num_last_blocks;
  stack_num_last_blocks = num_last_blocks;
  return stack_quot, last_blocks, stack_num_last_blocks;
}

// sigma_0 fuction for confuscating words for the message schedule
inline fn __sigma_0(reg u32 w) -> reg u32 {
  // compute the two right rotations and the right shift
  reg u32 w1 w2;
  w1 = w;
  w2 = w;
  _, _, w  = #ROR_32(w,  7);  // w rot 7
  _, _, w1 = #ROR_32(w1, 18); // w rot 18
  w2 >>= 3;                   // w >>  3
  
  w ^= w1;                    // (w rot 7) ^ (w rot 18)
  w ^= w2;                    // (w rot 7) ^ (w rot 18) ^ (w >> 3)

  return w;                   // (w rot 7) ^ (w rot 18) ^ (w >> 3)
}

// sigma_1 fuction for confuscating words for the message schedule
inline fn __sigma_1(reg u32 w) -> reg u32 {
  // compute the two right rotations and the right shift
  reg u32 w1 w2;
  w1 = w;
  w2 = w;
  _, _, w  = #ROR_32(w,  17); // w rot 17
  _, _, w1 = #ROR_32(w1, 19); // w rot 19
  w2 >>= 10;                  // w >>  10
  
  w ^= w1;                    // (w rot 17) ^ (w rot 19)
  w ^= w2;                    // (w rot 17) ^ (w rot 19) ^ (w >> 10)

  return w;                   // (w rot 17) ^ (w rot 19) ^ (w >> 10)
}

// compute the next word for the message schedule
inline fn __f_word(stack u32 stack_w_i w_i2 w_i7 w_i15 w_i16) -> stack u32 {
  reg u32 w_i temp;
  temp = w_i15;
  temp = __sigma_0(temp);

  w_i  = w_i2;           // w_{i-2}
  w_i  = __sigma_1(w_i); // sigma_1(w_{i-2})
  w_i += w_i7;           // sigma_1(w_{i-2}) + w_{i-7}
  w_i += temp;           // sigma_1(w_{i-2}) + w_{i-7} + sigma_0(w_{i-15})
  w_i += w_i16;          // sigma_1(w_{i-2}) + w_{i-7} + sigma_0(w_{i-15}) + w_{i-16}

  w_i = #BSWAP_32(w_i);
  stack_w_i = w_i;
  return stack_w_i;      // sigma_1(w_{i-2}) + w_{i-7} + sigma_0(w_{i-15}) + w_{i-16}
}

// take a message block and produce a message schedule from it
inline fn __f_sch(stack u32[64] sch, stack u32[16] block) -> stack u32[64] {
  // copy the message block into the first 16 words
  inline int i;
  for i=0 to 16 {
    sch[i] = block[i];
  }

  // compute the rest of the words in the message schedule
  for i=16 to 64 {
    reg u32[4] sch_s;
    sch_s[0] = sch[i-2];  sch_s[0] = #BSWAP_32(sch_s[0]);
    sch_s[1] = sch[i-7];  sch_s[1] = #BSWAP_32(sch_s[1]);
    sch_s[2] = sch[i-15]; sch_s[2] = #BSWAP_32(sch_s[2]);
    sch_s[3] = sch[i-16]; sch_s[3] = #BSWAP_32(sch_s[3]);

    sch[i] = __f_word(sch[i], sch_s[0], sch_s[1], sch_s[2], sch_s[3]);
  }

  return sch; // return the entire message schedule
}

// Sigma_0 fuction for confuscating words in the main loop
inline fn __Sigma_0(reg u32 w) -> reg u32 {
  // compute the three right rotations
  reg u32 w1 w2 w3;
  w1 = w; w2 = w; w3 = w;

  _, _, w1 = #ROR_32(w1,  2); // w rot 2
  _, _, w2 = #ROR_32(w2, 13); // w rot 13
  _, _, w3 = #ROR_32(w3, 22); // w rot 22
  
  w  = w1;
  w ^= w2;                    // (w rot 2) ^ (w rot 13)
  w ^= w3;                    // (w rot 2) ^ (w rot 13) ^ (w rot 22)

  return w;                   // (w rot 2) ^ (w rot 13) ^ (w rot 22)
}

// Sigma_1 fuction for confuscating words in the main loop
inline fn __Sigma_1(reg u32 w) -> reg u32 {
  // compute the three right rotations
  reg u32 w1 w2 w3;
  w1 = w; w2 = w; w3 = w;

  _, _, w1 = #ROR_32(w1,  6); // w rot 6
  _, _, w2 = #ROR_32(w2, 11); // w rot 11
  _, _, w3 = #ROR_32(w3, 25); // w rot 25
  
  w  = w1;
  w ^= w2;                    // (w rot 6) ^ (w rot 11)
  w ^= w3;                    // (w rot 6) ^ (w rot 11) ^ (w rot 25)

  return w;                   // (w rot 6) ^ (w rot 11) ^ (w rot 25)
}

// majority function that computes the bitwise majority of three words
inline fn __f_maj(reg u32 x y z) -> reg u32 {
  reg u32 t u;

  t  = x; // t = x
  t &= z; // t = (x & z)
  u  = x;
  u &= y; // x = (x & y)
  u ^= t; // x = (x & y) ^ (x & z)
  t  = y; // t = y
  t &= z; // t = (y & z)
  x  = u;
  x ^= t; // x = (x & y) ^ (x & z) ^ (y & z)

  return x; // (x & y) ^ (x & z) ^ (y & z)
}

// choice function that selects the bits from y and z based on the bits in x
inline fn __f_cho(reg u32 x y z) -> reg u32 {
  reg u32 t u;

  t  =  x; // t = x
  t  = !t; // t = !x
  t &=  z; // t = (!x & z)
  u  =  x;
  u &=  y; // x = (x & y)
  x  =  u;
  x ^=  t; // x = (x & y) ^ (!x & z)

  return x; // (x & y) ^ (!x & z)
}

// round function that takes the working variables and updates them
inline fn __f_rou(reg u32[8] t, stack u32 w_i k_i) -> reg u32[8] {
  reg u32 t_1 t_2 fun;

  // compute t_1
  t_1  = t[7];                     // t_1 = t_h
  t_1 += w_i;                      // t_1 = t_h + w_i
  t_1 += k_i;                      // t_1 = t_h + w_i + k_i
  fun = __f_cho(t[4], t[5], t[6]); // fun = f_cho(t_e, t_f, t_g)
  t_1 += fun;                      // t_1 = t_h + w_i + k_i + f_cho(t_e, t_f, t_g)
  fun = __Sigma_1(t[4]);           // fun = Sigma_1(t_e)
  t_1 += fun;                      // t_1 = t_h + w_i + k_i + f_cho(t_e, t_f, t_g) + Sigma_1(t_e)

  // compute t_2
  fun = __f_maj(t[0], t[1], t[2]); // fun = f_maj(t_a, t_b, t_c)
  t_2 = fun;                       // t_2 = f_maj(t_a, t_b, t_c)
  fun = __Sigma_0(t[0]);           // fun = Sigma_0(t_a)
  t_2 += fun;                      // t_2 = f_maj(t_a, t_b, t_c) + Sigma_0(t_a)

  // update the working variables
  t[7] = t[6];              // t_h = t_g
  t[6] = t[5];              // t_g = t_f
  t[5] = t[4];              // t_f = t_e
  t[4] = t[3]; t[4] += t_1; // t_e = t_d + t_1
  t[3] = t[2];              // t_d = t_c
  t[2] = t[1];              // t_c = t_b
  t[1] = t[0];              // t_b = t_a
  t[0] = t_1;  t[0] += t_2; // t_a = t_1 + t_2

  return t;
}

// main loop that takes and updates the IHVs through iterated calls of the round function
inline fn __f_loop(stack u32[8] ihv, stack u32[64] sch) -> stack u32[8] {
  reg u32[8]    t; // working variables
  stack u32[64] k; // loop constants
  k = SHA256_k;
  reg u32 sch_swap;

  // copy the IHVs into the working variables
  inline int j;
  for j=0 to 8 {
    t[j] = ihv[j];
    t[j] = #BSWAP_32(t[j]);
  }

  // run the round function 64 times on the working variables
  inline int i;
  for i=0 to 64 {
    sch_swap = sch[i];
    sch_swap = #BSWAP_32(sch_swap);
    t = __f_rou(t, sch_swap, k[i]);
  }

  // add the working variables to the IHVs
  for j=0 to 8 {
    reg u32 ihv_swap;
    ihv_swap = ihv[j]; ihv_swap = #BSWAP_32(ihv_swap);

    t[j] += ihv_swap;
    t[j]  = #BSWAP_32(t[j]);

    ihv[j] = t[j];
  }

  return ihv; // return the updated IHVs
}

// process the message blocks that consist entirely of message bytes
inline fn __f_comp_first(stack u32[8] ihv, reg u64 mess_addr, stack u64 num_first_blocks) -> stack u32[8] {
  stack u32[16] block; // message block
  stack u32[64] sch;   // message schedule
  
  reg u64 i;
  i = 0;
  while (i<num_first_blocks) {
    // copy the next block of the message word by word
    reg u64 i2;
    i2 = i;
    i2 <<= 4;
    inline int j;
    for j=0 to 16 {
      block[j] = (u32)[mess_addr + i2 + j];
    }

    sch = __f_sch(sch, block); // compute the message schedule
    ihv = __f_loop(ihv, sch);  // run the main loop and update the IHVs

    i += 1;
  }

  return ihv;
}

// process the message blocks that comprise the blocks with padding
inline fn __f_comp_last(stack u32[8] ihv, stack u32[32] last_blocks, stack u64 num_last_blocks) -> stack u32[8] {
  stack u32[16] block; // message block
  stack u32[64] sch;   // message schedule
  
  reg u64 i;
  i = 0;
  while (i<num_last_blocks) {
    // copy the next block of the message word by word
    reg u64 i2;
    i2 = i;
    i2 <<= 4;
    inline int j;
    for j=0 to 16 {
      block[j] = last_blocks[i2 + j];
    }

    sch = __f_sch(sch, block); // compute the message schedule
    ihv = __f_loop(ihv, sch);  // run the main loop and update the IHVs

    i += 1;
  }

  return ihv;
}

// take the IHVs from the stack, and overwrite the hash value
inline fn __set_hash(stack u32[8] ihv, reg u64 hash) {
  inline int i;
  for i=0 to 8 {
    (u32)[hash + i*4] = ihv[i];
  }
}

// take a byte sequence mess_addr with length bytes, and compute and store its hash value at hash_addr_in
inline fn __sha256_ref_alt(reg u64 hash_addr_in mess_addr bytes) {
  // store the parameter addresses on the stack
  stack u64 hash_addr_st; // hash address on the stack
  hash_addr_st = hash_addr_in;

  // compute the message padding
  stack u64 num_first_blocks; // number indicating the number of blocks fully filled with message bytes
  stack u64 num_last_blocks;  // number indicating the number of blocks containing padding (1 or 2)
  stack u32[32] last_blocks;  // space for two blocks of 512 bits, split in 32-bit words
  num_first_blocks, last_blocks, num_last_blocks = __f_pad(mess_addr, bytes);

  // initialise the IHVs on the stack
  stack u32[8] ihv;
  ihv = __init_ihv();

  // run the compression function iteratively on message blocks consisting fully of message bytes
  ihv = __f_comp_first(ihv, mess_addr, num_first_blocks);

  // run the compression function on the last (two) message block(s) containing padding
  ihv = __f_comp_last(ihv, last_blocks, num_last_blocks);

  // set the hash value to the IHVs
  reg u64 hash_addr;          // hash address
  hash_addr = hash_addr_st;   // copy the hash address from the stack
  __set_hash(ihv, hash_addr);
}



























